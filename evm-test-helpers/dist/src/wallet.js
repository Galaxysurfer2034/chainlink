"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fundWallet = exports.createWallet = exports.createFundedWallet = void 0;
/**
 * @packageDocumentation
 *
 * This file contains functionality for ease of creating ethereum account abstractions
 * based on ethers.js. Useful for creating many accounts for testing purposes only.
 */
const ethers_1 = require("ethers");
const debug_1 = require("./debug");
/**
 * Create a pre-funded wallet with all defaults
 *
 * @param provider The provider to connect to the created wallet and to withdraw funds from
 * @param accountIndex The account index of the corresponding wallet derivation path
 */
async function createFundedWallet(provider, accountIndex) {
    const wallet = createWallet(provider, accountIndex);
    const receipt = await fundWallet(wallet, provider);
    return { wallet, receipt };
}
exports.createFundedWallet = createFundedWallet;
/**
 * Create an ethers.js wallet instance that is connected to the given provider
 *
 * @param provider A compatible ethers.js provider such as the one returned by `ganache.provider()` to connect the wallet to
 * @param accountIndex The account index to derive from the mnemonic phrase
 */
function createWallet(provider, accountIndex) {
    const debug = debug_1.makeDebug('wallet:createWallet');
    if (accountIndex < 0) {
        throw Error(`Account index must be greater than 0, got ${accountIndex}`);
    }
    /**
     * THIS IS FOR TESTING PURPOSES ONLY
     */
    const mnemonicPhrase = 'dose weasel clever culture letter volume endorse used harvest ripple circle install';
    const path = `m/44'/60'/${accountIndex}'/0/0`;
    debug('created wallet with parameters: %o', { mnemonicPhrase, path });
    return ethers_1.ethers.Wallet.fromMnemonic(mnemonicPhrase, path).connect(provider);
}
exports.createWallet = createWallet;
/**
 * Fund a wallet with unlocked accounts available from the given provider
 *
 * @param wallet The ethers wallet to fund
 * @param provider The provider which has control over unlocked, funded accounts to transfer funds from
 * @param overrides Transaction parameters to override when sending the funding transaction
 */
async function fundWallet(wallet, provider, overrides) {
    const debug = debug_1.makeDebug('wallet:fundWallet');
    debug('funding wallet');
    debug('retreiving accounts...');
    const nodeOwnedAccounts = await provider.listAccounts();
    debug('retreived accounts: %o', nodeOwnedAccounts);
    const signer = provider.getSigner(nodeOwnedAccounts[0]);
    const txParams = {
        to: wallet.address,
        value: ethers_1.ethers.utils.parseEther('10'),
        ...overrides,
    };
    debug('sending tx with the following parameters: %o', txParams);
    const tx = await signer.sendTransaction(txParams);
    debug('waiting on tx %s to complete...', tx.hash);
    const receipt = await tx.wait();
    debug('tx %s confirmed with tx receipt %o', tx.hash, receipt);
    return receipt;
}
exports.fundWallet = fundWallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3dhbGxldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7Ozs7R0FLRztBQUNILG1DQUErQjtBQUUvQixtQ0FBbUM7QUFZbkM7Ozs7O0dBS0c7QUFDSSxLQUFLLFVBQVUsa0JBQWtCLENBQ3RDLFFBQXlCLEVBQ3pCLFlBQW9CO0lBRXBCLE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUE7SUFDbkQsTUFBTSxPQUFPLEdBQUcsTUFBTSxVQUFVLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBRWxELE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLENBQUE7QUFDNUIsQ0FBQztBQVJELGdEQVFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixZQUFZLENBQzFCLFFBQTBDLEVBQzFDLFlBQW9CO0lBRXBCLE1BQU0sS0FBSyxHQUFHLGlCQUFTLENBQUMscUJBQXFCLENBQUMsQ0FBQTtJQUM5QyxJQUFJLFlBQVksR0FBRyxDQUFDLEVBQUU7UUFDcEIsTUFBTSxLQUFLLENBQUMsNkNBQTZDLFlBQVksRUFBRSxDQUFDLENBQUE7S0FDekU7SUFFRDs7T0FFRztJQUNILE1BQU0sY0FBYyxHQUNsQixxRkFBcUYsQ0FBQTtJQUV2RixNQUFNLElBQUksR0FBRyxhQUFhLFlBQVksT0FBTyxDQUFBO0lBQzdDLEtBQUssQ0FBQyxvQ0FBb0MsRUFBRSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFBO0lBRXJFLE9BQU8sZUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQTtBQUMzRSxDQUFDO0FBbkJELG9DQW1CQztBQUVEOzs7Ozs7R0FNRztBQUNJLEtBQUssVUFBVSxVQUFVLENBQzlCLE1BQXFCLEVBQ3JCLFFBQTBDLEVBQzFDLFNBQW9FO0lBRXBFLE1BQU0sS0FBSyxHQUFHLGlCQUFTLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtJQUM1QyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtJQUV2QixLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQTtJQUUvQixNQUFNLGlCQUFpQixHQUFHLE1BQU0sUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFBO0lBQ3ZELEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxpQkFBaUIsQ0FBQyxDQUFBO0lBRWxELE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUV2RCxNQUFNLFFBQVEsR0FBd0M7UUFDcEQsRUFBRSxFQUFFLE1BQU0sQ0FBQyxPQUFPO1FBQ2xCLEtBQUssRUFBRSxlQUFNLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7UUFDcEMsR0FBRyxTQUFTO0tBQ2IsQ0FBQTtJQUNELEtBQUssQ0FBQyw4Q0FBOEMsRUFBRSxRQUFRLENBQUMsQ0FBQTtJQUMvRCxNQUFNLEVBQUUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUE7SUFFakQsS0FBSyxDQUFDLGlDQUFpQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUNqRCxNQUFNLE9BQU8sR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQTtJQUMvQixLQUFLLENBQUMsb0NBQW9DLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQTtJQUM3RCxPQUFPLE9BQU8sQ0FBQTtBQUNoQixDQUFDO0FBM0JELGdDQTJCQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGZ1bmN0aW9uYWxpdHkgZm9yIGVhc2Ugb2YgY3JlYXRpbmcgZXRoZXJldW0gYWNjb3VudCBhYnN0cmFjdGlvbnNcbiAqIGJhc2VkIG9uIGV0aGVycy5qcy4gVXNlZnVsIGZvciBjcmVhdGluZyBtYW55IGFjY291bnRzIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG4gKi9cbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycydcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gJ2V0aGVycy9wcm92aWRlcnMnXG5pbXBvcnQgeyBtYWtlRGVidWcgfSBmcm9tICcuL2RlYnVnJ1xuXG5pbnRlcmZhY2UgUkNyZWF0ZUZ1bmRlZFdhbGxldCB7XG4gIC8qKlxuICAgKiBUaGUgY3JlYXRlZCB3YWxsZXRcbiAgICovXG4gIHdhbGxldDogZXRoZXJzLldhbGxldFxuICAvKipcbiAgICogVGhlIHJlY2VpcHQgb2YgdGhlIHR4IHRoYXQgZnVuZGVkIHRoZSBjcmVhdGVkIHdhbGxldFxuICAgKi9cbiAgcmVjZWlwdDogZXRoZXJzLnByb3ZpZGVycy5UcmFuc2FjdGlvblJlY2VpcHRcbn1cbi8qKlxuICogQ3JlYXRlIGEgcHJlLWZ1bmRlZCB3YWxsZXQgd2l0aCBhbGwgZGVmYXVsdHNcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgVGhlIHByb3ZpZGVyIHRvIGNvbm5lY3QgdG8gdGhlIGNyZWF0ZWQgd2FsbGV0IGFuZCB0byB3aXRoZHJhdyBmdW5kcyBmcm9tXG4gKiBAcGFyYW0gYWNjb3VudEluZGV4IFRoZSBhY2NvdW50IGluZGV4IG9mIHRoZSBjb3JyZXNwb25kaW5nIHdhbGxldCBkZXJpdmF0aW9uIHBhdGhcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUZ1bmRlZFdhbGxldChcbiAgcHJvdmlkZXI6IEpzb25ScGNQcm92aWRlcixcbiAgYWNjb3VudEluZGV4OiBudW1iZXIsXG4pOiBQcm9taXNlPFJDcmVhdGVGdW5kZWRXYWxsZXQ+IHtcbiAgY29uc3Qgd2FsbGV0ID0gY3JlYXRlV2FsbGV0KHByb3ZpZGVyLCBhY2NvdW50SW5kZXgpXG4gIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCBmdW5kV2FsbGV0KHdhbGxldCwgcHJvdmlkZXIpXG5cbiAgcmV0dXJuIHsgd2FsbGV0LCByZWNlaXB0IH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXRoZXJzLmpzIHdhbGxldCBpbnN0YW5jZSB0aGF0IGlzIGNvbm5lY3RlZCB0byB0aGUgZ2l2ZW4gcHJvdmlkZXJcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgQSBjb21wYXRpYmxlIGV0aGVycy5qcyBwcm92aWRlciBzdWNoIGFzIHRoZSBvbmUgcmV0dXJuZWQgYnkgYGdhbmFjaGUucHJvdmlkZXIoKWAgdG8gY29ubmVjdCB0aGUgd2FsbGV0IHRvXG4gKiBAcGFyYW0gYWNjb3VudEluZGV4IFRoZSBhY2NvdW50IGluZGV4IHRvIGRlcml2ZSBmcm9tIHRoZSBtbmVtb25pYyBwaHJhc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVdhbGxldChcbiAgcHJvdmlkZXI6IGV0aGVycy5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyLFxuICBhY2NvdW50SW5kZXg6IG51bWJlcixcbik6IGV0aGVycy5XYWxsZXQge1xuICBjb25zdCBkZWJ1ZyA9IG1ha2VEZWJ1Zygnd2FsbGV0OmNyZWF0ZVdhbGxldCcpXG4gIGlmIChhY2NvdW50SW5kZXggPCAwKSB7XG4gICAgdGhyb3cgRXJyb3IoYEFjY291bnQgaW5kZXggbXVzdCBiZSBncmVhdGVyIHRoYW4gMCwgZ290ICR7YWNjb3VudEluZGV4fWApXG4gIH1cblxuICAvKipcbiAgICogVEhJUyBJUyBGT1IgVEVTVElORyBQVVJQT1NFUyBPTkxZXG4gICAqL1xuICBjb25zdCBtbmVtb25pY1BocmFzZSA9XG4gICAgJ2Rvc2Ugd2Vhc2VsIGNsZXZlciBjdWx0dXJlIGxldHRlciB2b2x1bWUgZW5kb3JzZSB1c2VkIGhhcnZlc3QgcmlwcGxlIGNpcmNsZSBpbnN0YWxsJ1xuXG4gIGNvbnN0IHBhdGggPSBgbS80NCcvNjAnLyR7YWNjb3VudEluZGV4fScvMC8wYFxuICBkZWJ1ZygnY3JlYXRlZCB3YWxsZXQgd2l0aCBwYXJhbWV0ZXJzOiAlbycsIHsgbW5lbW9uaWNQaHJhc2UsIHBhdGggfSlcblxuICByZXR1cm4gZXRoZXJzLldhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWNQaHJhc2UsIHBhdGgpLmNvbm5lY3QocHJvdmlkZXIpXG59XG5cbi8qKlxuICogRnVuZCBhIHdhbGxldCB3aXRoIHVubG9ja2VkIGFjY291bnRzIGF2YWlsYWJsZSBmcm9tIHRoZSBnaXZlbiBwcm92aWRlclxuICpcbiAqIEBwYXJhbSB3YWxsZXQgVGhlIGV0aGVycyB3YWxsZXQgdG8gZnVuZFxuICogQHBhcmFtIHByb3ZpZGVyIFRoZSBwcm92aWRlciB3aGljaCBoYXMgY29udHJvbCBvdmVyIHVubG9ja2VkLCBmdW5kZWQgYWNjb3VudHMgdG8gdHJhbnNmZXIgZnVuZHMgZnJvbVxuICogQHBhcmFtIG92ZXJyaWRlcyBUcmFuc2FjdGlvbiBwYXJhbWV0ZXJzIHRvIG92ZXJyaWRlIHdoZW4gc2VuZGluZyB0aGUgZnVuZGluZyB0cmFuc2FjdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnVuZFdhbGxldChcbiAgd2FsbGV0OiBldGhlcnMuV2FsbGV0LFxuICBwcm92aWRlcjogZXRoZXJzLnByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIsXG4gIG92ZXJyaWRlcz86IE9taXQ8ZXRoZXJzLnByb3ZpZGVycy5UcmFuc2FjdGlvblJlcXVlc3QsICd0bycgfCAnZnJvbSc+LFxuKTogUHJvbWlzZTxldGhlcnMucHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVjZWlwdD4ge1xuICBjb25zdCBkZWJ1ZyA9IG1ha2VEZWJ1Zygnd2FsbGV0OmZ1bmRXYWxsZXQnKVxuICBkZWJ1ZygnZnVuZGluZyB3YWxsZXQnKVxuXG4gIGRlYnVnKCdyZXRyZWl2aW5nIGFjY291bnRzLi4uJylcblxuICBjb25zdCBub2RlT3duZWRBY2NvdW50cyA9IGF3YWl0IHByb3ZpZGVyLmxpc3RBY2NvdW50cygpXG4gIGRlYnVnKCdyZXRyZWl2ZWQgYWNjb3VudHM6ICVvJywgbm9kZU93bmVkQWNjb3VudHMpXG5cbiAgY29uc3Qgc2lnbmVyID0gcHJvdmlkZXIuZ2V0U2lnbmVyKG5vZGVPd25lZEFjY291bnRzWzBdKVxuXG4gIGNvbnN0IHR4UGFyYW1zOiBldGhlcnMucHJvdmlkZXJzLlRyYW5zYWN0aW9uUmVxdWVzdCA9IHtcbiAgICB0bzogd2FsbGV0LmFkZHJlc3MsXG4gICAgdmFsdWU6IGV0aGVycy51dGlscy5wYXJzZUV0aGVyKCcxMCcpLFxuICAgIC4uLm92ZXJyaWRlcyxcbiAgfVxuICBkZWJ1Zygnc2VuZGluZyB0eCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogJW8nLCB0eFBhcmFtcylcbiAgY29uc3QgdHggPSBhd2FpdCBzaWduZXIuc2VuZFRyYW5zYWN0aW9uKHR4UGFyYW1zKVxuXG4gIGRlYnVnKCd3YWl0aW5nIG9uIHR4ICVzIHRvIGNvbXBsZXRlLi4uJywgdHguaGFzaClcbiAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKVxuICBkZWJ1ZygndHggJXMgY29uZmlybWVkIHdpdGggdHggcmVjZWlwdCAlbycsIHR4Lmhhc2gsIHJlY2VpcHQpXG4gIHJldHVybiByZWNlaXB0XG59XG4iXX0=