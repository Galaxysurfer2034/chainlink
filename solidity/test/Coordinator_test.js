import {
  assertActionThrows,
  bigNum,
  checkPublicABI,
  concatTypedArrays,
  deploy,
  newAddress,
  newHash,
  newSignature,
  newUint8ArrayFromStr,
  oracleNode,
  splitRPCSignature,
  stranger,
  toBuffer,
  toHex,
  toHexWithoutPrefix
} from './support/helpers'
import { assertBigNum } from './support/matchers'
import utils from 'ethereumjs-util'

const REQUEST_DIGEST_PREFIX = newUint8ArrayFromStr('\x19Ethereum Signed Message:\n')

contract('Coordinator', () => {
  const sourcePath = 'Coordinator.sol'
  let coordinator

  beforeEach(async () => {
    coordinator = await deploy(sourcePath)
  })

  it('has a limited public interface', () => {
    checkPublicABI(artifacts.require(sourcePath), [
      'getId',
      'initiateServiceAgreement',
      'serviceAgreements'
    ])
  })

  describe('#getId', () => {
    it('matches the ID generated by the oracle off-chain', async () => {
      let result = await coordinator.getId.call(
        1,
        2,
        ['0x70AEc4B9CFFA7b55C0711b82DD719049d615E21d', '0xd26114cd6EE289AccF82350c8d8487fedB8A0C07'],
        '0x85820c5ec619a1f517ee6cfeff545ec0ca1a90206e1a38c47f016d4137e801dd'
      )
      assert.equal(result, '0x2249a9e0a0463724551b2980299a16406da6f4e80d911628ee77445be4e04e7c')
    })
  })

  describe('#initiateServiceAgreement', () => {
    let payment, expiration, account, oracles, requestDigest, serviceAgreementID,
      oracleSignature, v, r, s

    beforeEach(async () => {
      payment = newHash('1000000000000000000')
      expiration = newHash('300')
      account = newAddress(oracleNode)
      oracles = [account]
      requestDigest = newHash('0x9ebed6ae16d275059bf4de0e01482b0eca7ffc0ffcc1918db61e17ac0f7dedc8')

      const serviceAgreementIDInput = concatTypedArrays(
        payment,
        expiration,
        concatTypedArrays(...(oracles.map(a => newHash(toHex(a))))),
        requestDigest)
      const serviceAgreementIDInputDigest = utils.sha3(toHex(serviceAgreementIDInput))
      serviceAgreementID = newHash(toHex(serviceAgreementIDInputDigest))
    })

    context("with valid oracle signatures", () => {
      beforeEach(async () => {
        oracleSignature = newSignature(web3.eth.sign(toHexWithoutPrefix(account), toHexWithoutPrefix(serviceAgreementID)))

        const sigObject = splitRPCSignature(oracleSignature)
        v = sigObject.v
        r = sigObject.r
        s = sigObject.s

        const requestDigestPrefixedMsg = concatTypedArrays(
          REQUEST_DIGEST_PREFIX,
          newUint8ArrayFromStr(serviceAgreementID.length.toString()),
          serviceAgreementID
        )
        const requestDigestPubKey =
          utils.ecrecover(utils.sha3(toBuffer(requestDigestPrefixedMsg)), v, toBuffer(r), toBuffer(s))
        const requestDigestAddr = utils.pubToAddress(requestDigestPubKey)

        assert.equal(toHex(account), toHex(requestDigestAddr))
      })

      it('saves a service agreement struct from the parameters', async () => {
        await coordinator.initiateServiceAgreement(
          toHex(payment),
          toHex(expiration),
          oracles.map(toHex),
          [v],
          [r].map(toHex),
          [s].map(toHex),
          toHex(requestDigest)
        )

        const sa = await coordinator.serviceAgreements.call(toHex(serviceAgreementID))

        assertBigNum(sa[0], bigNum(toHex(payment)))
        assertBigNum(sa[1], bigNum(toHex(expiration)))
        assert.equal(sa[2], toHex(requestDigest))

        /// / TODO:
        /// / Web3.js doesn't support generating an artifact for arrays within a struct.
        /// / This means that we aren't returned the list of oracles and
        /// / can't assert on their values.
        /// /
        /// / However, we can pass them into the function to generate the ID
        /// / & solidity won't compile unless we pass the correct number and
        /// / type of params when initializing the ServiceAgreement struct,
        /// / so we have some indirect test coverage.
        /// /
        /// / https://github.com/ethereum/web3.js/issues/1241
        /// / assert.equal(
        /// /   sa[2],
        /// /   ['0x70AEc4B9CFFA7b55C0711b82DD719049d615E21d', '0xd26114cd6EE289AccF82350c8d8487fedB8A0C07']
        /// / )
      })
    })

    context("with an invalid oracle signatures", () => {
      beforeEach(async () => {
        oracleSignature = newSignature(web3.eth.sign(stranger, toHexWithoutPrefix(serviceAgreementID)))

        const sigObject = splitRPCSignature(oracleSignature)
        v = sigObject.v
        r = sigObject.r
        s = sigObject.s
      })

      it('saves a service agreement struct from the parameters', async () => {
        assertActionThrows(async () => {
          await coordinator.initiateServiceAgreement(
            toHex(payment),
            toHex(expiration),
            oracles.map(toHex),
            [v],
            [r].map(toHex),
            [s].map(toHex),
            toHex(requestDigest)
          )
        })

        const sa = await coordinator.serviceAgreements.call(toHex(serviceAgreementID))
        assertBigNum(sa[0], bigNum(0))
        assertBigNum(sa[1], bigNum(0))
        assert.equal(sa[2], '0x0000000000000000000000000000000000000000000000000000000000000000')
      })
    })
  })
})
