import * as h from '../src/helpers'
import { ethers } from 'ethers'
import { ContractReceipt } from 'ethers/contract'
import { LinkTokenFactory } from '../src/generated/LinkTokenFactory'
import { CoordinatorFactory } from '../src/generated/CoordinatorFactory'
import { EmptyAggregatorFactory } from '../src/generated/EmptyAggregatorFactory'
import { MeanAggregatorFactory } from '../src/generated/MeanAggregatorFactory'
import { GetterSetterFactory } from '../src/generated/GetterSetterFactory'
import { MaliciousRequesterFactory } from '../src/generated/MaliciousRequesterFactory'
import { MaliciousConsumerFactory } from '../src/generated/MaliciousConsumerFactory'
import { Instance } from '../src/contract'
import { makeTestProvider } from '../src/provider'
import { assert } from 'chai'
import { assertBigNum } from '../src/matchers'
import { BigNumberish } from 'ethers/utils'

const provider = makeTestProvider()

const linkTokenFactory = new LinkTokenFactory()
const coordinatorFactory = new CoordinatorFactory()
const emptyAggregatorFactory = new EmptyAggregatorFactory()
const meanAggregatorFactory = new MeanAggregatorFactory()
const getterSetterFactory = new GetterSetterFactory()
const maliciousRequesterFactory = new MaliciousRequesterFactory()
const maliciousConsumerFactory = new MaliciousConsumerFactory()

const oracleRequestEvent = coordinatorFactory.interface.events.OracleRequest
const newServiceAgreementEvent =
  coordinatorFactory.interface.events.NewServiceAgreement

let roles: h.Roles

let link: Instance<LinkTokenFactory>
let coordinator: Instance<CoordinatorFactory>
let emptyAggregator: Instance<EmptyAggregatorFactory>
let meanAggregator: Instance<MeanAggregatorFactory>
let oracle1: string
let oracle2: string
let oracle3: string

const deployment = h.useSnapshot(provider, async () => {
  link = await linkTokenFactory.connect(roles.defaultAccount).deploy()
  coordinator = await coordinatorFactory
    .connect(roles.defaultAccount)
    .deploy(link.address)
  emptyAggregator = await emptyAggregatorFactory
    .connect(roles.defaultAccount)
    .deploy()
  meanAggregator = await meanAggregatorFactory
    .connect(roles.defaultAccount)
    .deploy()
})

beforeAll(async () => {
  roles = await h.initializeRolesAndPersonas(provider).then(x => x.roles)
  oracle1 = roles.oracleNode1.address
  oracle2 = roles.oracleNode2.address
  oracle3 = roles.oracleNode3.address
})

beforeEach(deployment)

describe('Coordinator', () => {
  it('has a limited public interface', () => {
    h.checkPublicABI(coordinatorFactory, [
      'EXPIRY_TIME',
      'balanceOf',
      'cancelOracleRequest',
      'depositFunds',
      'fulfillOracleRequest',
      'getId',
      'initiateServiceAgreement',
      'onTokenTransfer',
      'oracleRequest',
      'serviceAgreements',
      'withdraw',
      'withdrawableTokens',
    ])
  })

  describe('#getId', () => {
    it('matches the ID generated by the oracle off-chain', async () => {
      const agreement = await h.newServiceAgreement({
        payment: 1,
        expiration: 2,
        requestDigest:
          '0x85820c5ec619a1f517ee6cfeff545ec0ca1a90206e1a38c47f016d4137e801dd',
        aggregator: emptyAggregator.address,
      })
      const sAID = h.generateSAID(agreement)
      const sAAsData = h.encodeServiceAgreement(agreement)
      const result = await coordinator.getId(sAAsData)
      assert.equal(result.toLowerCase(), sAID)
    })
  })

  describe('#initiateServiceAgreement', () => {
    describe('with valid oracle signatures', () => {
      let serviceAgreement: h.ServiceAgreement
      let sAID: string
      let receipt: ContractReceipt

      beforeEach(async () => {
        serviceAgreement = await h.newServiceAgreement({
          oracles: [roles.oracleNode],
          aggregator: emptyAggregator.address,
        })
        sAID = h.generateSAID(serviceAgreement)
        const tx = await h.initiateServiceAgreement(
          coordinator,
          serviceAgreement,
        )
        receipt = await tx.wait()
      })

      it('saves a service agreement struct from the parameters', async () => {
        await h.assertServiceAgreementPresent(coordinator, serviceAgreement)
      })

      it('generates the SAID', async () => {
        const ethSAID = await coordinator.getId(
          h.encodeServiceAgreement(serviceAgreement),
        )
        assert.equal(ethSAID, sAID)
      })

      it('logs an event', async () => {
        expect(h.findEventIn(receipt, newServiceAgreementEvent)).toBeDefined()
      })

      it('calls the aggregator with the SA info', async () => {
        const event = h.findEventIn(receipt, newServiceAgreementEvent)
        assert(event, 'event was expected')
        const { said } = h.eventArgs(
          h.findEventIn(receipt, newServiceAgreementEvent),
        )
        assert.equal(said, sAID)
      })
    })

    describe('with an invalid oracle signature', () => {
      it('saves no service agreement struct, if signatures invalid', async () => {
        const serviceAgreement = await h.newServiceAgreement({
          oracles: [roles.oracleNode],
          aggregator: emptyAggregator.address,
        })
        const sAID = h.generateSAID(serviceAgreement)
        const badOracleSignature = await h.personalSign(sAID, roles.stranger)
        const badRequestDigestAddr = h.recoverAddressFromSignature(
          sAID,
          badOracleSignature,
        )
        assert.equal(roles.stranger.address, badRequestDigestAddr)
        const conbinedSignatures = h.combineOracleSignatures([
          badOracleSignature,
        ])
        await h.assertActionThrows(
          coordinator.initiateServiceAgreement(
            h.encodeServiceAgreement(serviceAgreement),
            h.encodeOracleSignatures(conbinedSignatures),
          ),
        )
        await h.assertServiceAgreementEmpty(coordinator, sAID)
      })
    })

    describe('Validation of service agreement deadlines', () => {
      it('Rejects a service agreement with an endAt date in the past', async () => {
        const serviceAgreement = await h.newServiceAgreement({
          endAt: 1,
          aggregator: emptyAggregator.address,
        })
        const sAID = h.generateSAID(serviceAgreement)
        await h.assertActionThrows(
          h.initiateServiceAgreement(coordinator, serviceAgreement),
        )
        await h.assertServiceAgreementEmpty(coordinator, sAID)
      })
    })
  })

  describe('#oracleRequest', () => {
    const to = '0x80e29acb842498fe6591f020bd82766dce619d43'
    let agreement: h.ServiceAgreement
    let fHash: string
    let sAID: string

    beforeEach(async () => {
      fHash = getterSetterFactory.interface.functions.requestedBytes32.sighash
      agreement = await h.newServiceAgreement({
        oracles: [roles.oracleNode],
        aggregator: meanAggregator.address,
      })
      sAID = h.generateSAID(agreement)
      await h.initiateServiceAgreement(coordinator, agreement)
      await link.transfer(roles.consumer.address, h.toWei('1000'))
    })

    describe('when called through the LINK token with enough payment', () => {
      it('logs an event', async () => {
        const payload = h.executeServiceAgreementBytes(sAID, to, fHash, '1')
        const tx = await link
          .connect(roles.consumer)
          .transferAndCall(coordinator.address, agreement.payment, payload)
        const receipt = await tx.wait()
        const event = h.findEventIn(receipt, oracleRequestEvent)
        const address = event.address
        const { sAId: loggedSAID } = oracleRequestEvent.decode(
          event.data,
          event.topics,
        )
        const req = h.decodeRunRequest(event)

        assert.equal(address, coordinator.address)
        assert.equal(sAID, loggedSAID)
        assertBigNum(
          roles.consumer.address,
          req.requester,
          "Logged consumer address doesn't match",
        )
        assertBigNum(
          agreement.payment,
          req.payment,
          "Logged payment amount doesn't match",
        )
      })
    })

    describe('when called through the LINK token with not enough payment', () => {
      it('throws an error', async () => {
        const calldata = h.executeServiceAgreementBytes(sAID, to, fHash, '1')
        const underPaid = h
          .bigNum(agreement.payment)
          .sub(h.bigNum(1))
          .toString()
        await h.assertActionThrows(
          link
            .connect(roles.consumer)
            .transferAndCall(coordinator.address, underPaid, calldata),
        )
      })
    })

    describe('when not called through the LINK token', () => {
      it('reverts', async () => {
        const txPromise = coordinator
          .connect(roles.consumer)
          .oracleRequest(
            ethers.constants.AddressZero,
            0,
            sAID,
            to,
            fHash,
            1,
            1,
            '0x',
          )
        await h.assertActionThrows(txPromise, 'Must use LINK token')
      })
    })
  })

  describe('#fulfillOracleRequest', () => {
    let agreement: h.ServiceAgreement
    let sAID: string
    let mock: Instance<GetterSetterFactory>
    let request: h.RunRequest
    let fHash: string
    beforeEach(async () => {
      agreement = await h.newServiceAgreement({
        oracles: [roles.oracleNode],
        aggregator: meanAggregator.address,
      })
      sAID = h.generateSAID(agreement)
      const tx = await h.initiateServiceAgreement(coordinator, agreement)
      const receipt = await tx.wait()
      const event = h.findEventIn(receipt, newServiceAgreementEvent)
      const { said: loggedSAID } = newServiceAgreementEvent.decode(
        event.data,
        event.topics,
      )
      assert.equal(loggedSAID, sAID)

      fHash = getterSetterFactory.interface.functions.requestedBytes32.sighash
    })

    describe('cooperative consumer', () => {
      const message = h.toBytes32String('Hello World!')
      beforeEach(async () => {
        mock = await getterSetterFactory.connect(roles.defaultAccount).deploy()
        const payload = h.executeServiceAgreementBytes(
          sAID,
          mock.address,
          fHash,
          1,
        )
        const tx = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
        )
        const receipt = await tx.wait()
        const eventLog = h.findEventIn(receipt, oracleRequestEvent)
        request = h.decodeRunRequest(eventLog)
      })

      describe('when called by a non-owner', () => {
        // Turn this test on when multiple-oracle response aggregation is enabled
        xit('raises an error', async () => {
          await h.assertActionThrows(
            coordinator
              .connect(roles.stranger)
              .fulfillOracleRequest(request.id, message),
          )
        })
      })

      describe('when called by an owner', () => {
        it('raises an error if the request ID does not exist', async () => {
          const invalidRequestId = h.toBytes32String('deadbeef')
          await h.assertActionThrows(
            coordinator
              .connect(roles.oracleNode)
              .fulfillOracleRequest(invalidRequestId, message),
          )
        })

        it('sets the value on the requested contract', async () => {
          await coordinator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(request.id, message)
          const mockRequestId = await mock.requestId()
          assert.equal(h.toHex(request.id), mockRequestId)
          const currentValue = await mock.getBytes32()
          assert.equal('Hello World!', h.parseBytes32String(currentValue))
        })

        it('reports errors from the aggregator, such as double-reporting', async () => {
          const firstMessage = h.toBytes32String('First message!')
          const seccondMessage = h.toBytes32String('Second message!!')
          await coordinator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(request.id, firstMessage)
          await h.assertActionThrows(
            coordinator
              .connect(roles.oracleNode)
              .fulfillOracleRequest(request.id, seccondMessage),
            'oracle already reported',
          )
        })
      })
    })

    describe('with a malicious requester', () => {
      let mock: Instance<MaliciousRequesterFactory>
      const paymentAmount = h.toWei('1')

      beforeEach(async () => {
        mock = await maliciousRequesterFactory
          .connect(roles.defaultAccount)
          .deploy(link.address, coordinator.address)
        await link.transfer(mock.address, paymentAmount)
      })

      xit('cannot cancel before the expiration', async () => {
        await h.assertActionThrows(
          mock.maliciousRequestCancel(sAID, 'doesNothing(bytes32,bytes32)'),
        )
      })

      it('cannot call functions on the LINK token through callbacks', async () => {
        await h.assertActionThrows(
          mock.request(
            sAID,
            link.address,
            linkTokenFactory.interface.functions.transfer.sighash,
          ),
        )
      })

      describe('requester lies about amount of LINK sent', () => {
        it('the oracle uses the amount of LINK actually paid', async () => {
          const tx = await mock.maliciousPrice(sAID)
          const receipt = await tx.wait()
          const eventLog = h.findEventIn(receipt, oracleRequestEvent)
          const req = h.decodeRunRequest(eventLog)
          assertBigNum(
            paymentAmount,
            req.payment,
            [
              'Malicious data request tricked oracle into refunding more than',
              'the requester paid, by claiming a larger amount',
              `(${req.payment}) than the requester paid (${paymentAmount})`,
            ].join(' '),
          )
        })
      })
    })

    describe('with a malicious consumer', () => {
      const paymentAmount = h.toWei('1')
      let mock: Instance<MaliciousConsumerFactory>

      beforeEach(async () => {
        mock = await maliciousConsumerFactory
          .connect(roles.defaultAccount)
          .deploy(link.address, coordinator.address)
        await link.transfer(mock.address, paymentAmount)
      })

      describe('fails during fulfillment', () => {
        beforeEach(async () => {
          const tx = await mock.requestData(
            sAID,
            maliciousConsumerFactory.interface.functions.assertFail.sighash,
          )
          const receipt = await tx.wait()
          const eventLog = h.findEventIn(receipt, oracleRequestEvent)
          request = h.decodeRunRequest(eventLog)
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(
              request.id,
              h.toBytes32String('hack the planet 101'),
            )

          const balance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(balance, 0)

          await coordinator
            .connect(roles.oracleNode)
            .withdraw(roles.oracleNode.address, paymentAmount)
          const newBalance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(paymentAmount, newBalance)
        })

        it("can't fulfill the data again", async () => {
          await coordinator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(
              request.id,
              h.toBytes32String('hack the planet 101'),
            )
          await h.assertActionThrows(
            coordinator
              .connect(roles.oracleNode)
              .fulfillOracleRequest(
                request.id,
                h.toBytes32String('hack the planet 102'),
              ),
            'oracle already reported',
          )
        })
      })

      describe('calls selfdestruct', () => {
        beforeEach(async () => {
          const tx = await mock.requestData(
            sAID,
            maliciousConsumerFactory.interface.functions.doesNothing.sighash,
          )
          const receipt = await tx.wait()
          const eventLog = h.findEventIn(receipt, oracleRequestEvent)
          request = h.decodeRunRequest(eventLog)
          await mock.remove()
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator.fulfillOracleRequest(
            request.id,
            h.toBytes32String('hack the planet 101'),
          )

          const balance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(balance, 0)

          await coordinator.withdraw(roles.oracleNode.address, paymentAmount)
          const newBalance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(paymentAmount, newBalance)
        })
      })

      describe('request is canceled during fulfillment', () => {
        beforeEach(async () => {
          const tx = await mock.requestData(
            sAID,
            maliciousConsumerFactory.interface.functions.cancelRequestOnFulfill
              .sighash,
          )
          const receipt = await tx.wait()
          const eventLog = h.findEventIn(receipt, oracleRequestEvent)
          request = h.decodeRunRequest(eventLog)
          const mockBalance = await link.balanceOf(mock.address)
          assertBigNum(mockBalance, h.bigNum(0))
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator.fulfillOracleRequest(
            request.id,
            h.toBytes32String('hack the planet 101'),
          )
          const mockBalance = await link.balanceOf(mock.address)
          assertBigNum(mockBalance, 0)
          const balance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(balance, 0)
          await coordinator.withdraw(roles.oracleNode.address, paymentAmount)
          const newBalance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(paymentAmount, newBalance)
        })

        it("can't fulfill the data again", async () => {
          await coordinator
            .connect(roles.oracleNode)
            .fulfillOracleRequest(
              request.id,
              h.toBytes32String('hack the planet 101'),
            )
          await h.assertActionThrows(
            coordinator
              .connect(roles.oracleNode)
              .fulfillOracleRequest(
                request.id,
                h.toBytes32String('hack the planet 102'),
              ),
          )
        })
      })
    })

    describe('when aggregating answers', () => {
      let request: h.RunRequest

      beforeEach(async () => {
        agreement = await h.newServiceAgreement({
          aggregator: meanAggregator.address,
          oracles: [roles.oracleNode1, roles.oracleNode2, roles.oracleNode3],
        })
        sAID = h.generateSAID(agreement)

        const tx1 = await h.initiateServiceAgreement(coordinator, agreement)
        const receipt1 = await tx1.wait()
        const event1 = h.findEventIn(receipt1, newServiceAgreementEvent)
        const { said: loggedSAID } = newServiceAgreementEvent.decode(
          event1.data,
          event1.topics,
        )
        assert.equal(loggedSAID, sAID)

        mock = await getterSetterFactory.connect(roles.defaultAccount).deploy()

        const fHash =
          getterSetterFactory.interface.functions.requestedUint256.sighash

        const payload = h.executeServiceAgreementBytes(
          sAID,
          mock.address,
          fHash,
          1,
        )
        const tx2 = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
        )
        const receipt2 = await tx2.wait()
        const event2 = h.findEventIn(receipt2, oracleRequestEvent)
        request = h.decodeRunRequest(event2)
      })

      it('does not set the value with only one oracle', async () => {
        const tx = await coordinator
          .connect(roles.oracleNode1)
          .fulfillOracleRequest(request.id, h.numToBytes32(17))
        const receipt = await tx.wait()
        assert.equal(receipt.logs?.length, 0) // No logs emitted = consuming contract not called
      })

      it('sets the average of the reported values', async () => {
        await coordinator
          .connect(roles.oracleNode1)
          .fulfillOracleRequest(request.id, h.numToBytes32(16))
        await coordinator
          .connect(roles.oracleNode2)
          .fulfillOracleRequest(request.id, h.numToBytes32(17))
        const tx = await coordinator
          .connect(roles.oracleNode3)
          .fulfillOracleRequest(request.id, h.numToBytes32(18))
        const receipt = await tx.wait()
        assert.equal(receipt.logs?.length, 1)
        const currentValue = await mock.getUint256()
        assertBigNum(currentValue, 17)
      })

      describe('when large values are provided in response', () => {
        // (uint256(-1) / 2) - 1
        const largeValue1 =
          '0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe'
        // (uint256(-1) / 2)
        const largeValue2 =
          '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
        // (uint256(-1) / 2) + 1
        const largeValue3 =
          '0x8000000000000000000000000000000000000000000000000000000000000000'

        beforeEach(async () => {
          await coordinator
            .connect(roles.oracleNode1)
            .fulfillOracleRequest(request.id, largeValue1)
          await coordinator
            .connect(roles.oracleNode2)
            .fulfillOracleRequest(request.id, largeValue2)
        })

        it('does not overflow', async () => {
          await coordinator
            .connect(roles.oracleNode3)
            .fulfillOracleRequest(request.id, largeValue3)
        })

        it('sets the average of the reported values', async () => {
          await coordinator
            .connect(roles.oracleNode3)
            .fulfillOracleRequest(request.id, largeValue3)
          const currentValue = await mock.getUint256()
          assertBigNum(largeValue2, currentValue)
          assert.notEqual(h.bigNum(0), h.bigNum(await mock.requestId())) // check if called
        })
      })

      it('successfully sets average when responses equal largest uint256', async () => {
        const largest =
          '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'

        await coordinator
          .connect(roles.oracleNode1)
          .fulfillOracleRequest(request.id, largest)
        await coordinator
          .connect(roles.oracleNode2)
          .fulfillOracleRequest(request.id, largest)
        await coordinator
          .connect(roles.oracleNode3)
          .fulfillOracleRequest(request.id, largest)
        const currentValue = await mock.getUint256()
        assertBigNum(h.bigNum(largest), currentValue)
        assert.notEqual(h.bigNum(0), h.bigNum(await mock.requestId())) // check if called
      })

      it('rejects oracles not part of the service agreement', async () => {
        await h.assertActionThrows(
          coordinator
            .connect(roles.stranger)
            .fulfillOracleRequest(request.id, h.numToBytes32(18)),
        )
      })

      describe('when an oracle reports multiple times', () => {
        beforeEach(async () => {
          await coordinator
            .connect(roles.oracleNode1)
            .fulfillOracleRequest(request.id, h.numToBytes32(16))
          await coordinator
            .connect(roles.oracleNode2)
            .fulfillOracleRequest(request.id, h.numToBytes32(17))
          await h.assertActionThrows(
            coordinator
              .connect(roles.oracleNode1)
              .fulfillOracleRequest(request.id, h.numToBytes32(18)),
          )
        })

        it('does not set the average', async () => {
          assertBigNum(0, await mock.requestId()) // check if called
        })

        it('still allows the other oracles to report', async () => {
          await coordinator
            .connect(roles.oracleNode3)
            .fulfillOracleRequest(request.id, h.numToBytes32(18))
          const currentValue = await mock.getUint256()
          assertBigNum(h.bigNum(17), currentValue)
          assert.notEqual(h.bigNum(0), h.bigNum(await mock.requestId())) // check if called
        })
      })
    })

    describe('after aggregation', () => {
      let request: h.RunRequest

      beforeEach(async () => {
        agreement = await h.newServiceAgreement({
          aggregator: meanAggregator.address,
          oracles: [roles.oracleNode1, roles.oracleNode2, roles.oracleNode3],
        })
        sAID = h.generateSAID(agreement)

        const tx1 = await h.initiateServiceAgreement(coordinator, agreement)
        const receipt1 = await tx1.wait()
        const event1 = h.findEventIn(receipt1, newServiceAgreementEvent)
        const { said: loggedSAID } = newServiceAgreementEvent.decode(
          event1.data,
          event1.topics,
        )
        assert.equal(loggedSAID, sAID)

        mock = await getterSetterFactory.connect(roles.defaultAccount).deploy()

        const fHash =
          getterSetterFactory.interface.functions.requestedUint256.sighash

        const payload = h.executeServiceAgreementBytes(
          sAID,
          mock.address,
          fHash,
          1,
        )
        const tx = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
        )
        const receipt = await tx.wait()
        const eventLog = h.findEventIn(receipt, oracleRequestEvent)
        request = h.decodeRunRequest(eventLog)

        await coordinator
          .connect(roles.oracleNode1)
          .fulfillOracleRequest(request.id, h.numToBytes32(16))
        await coordinator
          .connect(roles.oracleNode2)
          .fulfillOracleRequest(request.id, h.numToBytes32(17))
        await coordinator
          .connect(roles.oracleNode3)
          .fulfillOracleRequest(request.id, h.numToBytes32(18))

        const currentValue = await mock.getUint256()
        assertBigNum(h.bigNum(17), currentValue)
      })

      it('oracle balances are updated', async () => {
        // Given the 3 oracles from the SA, each should have the following balance after fulfillment
        const expected1 = h.bigNum('555555555555555555')
        const expected2 = h.bigNum('333333333333333333')
        const expected3 = h.bigNum('111111111111111111')
        const balance1 = await coordinator.withdrawableTokens(oracle1)
        const balance2 = await coordinator.withdrawableTokens(oracle2)
        const balance3 = await coordinator.withdrawableTokens(oracle3)
        assertBigNum(expected1, balance1)
        assertBigNum(expected2, balance2)
        assertBigNum(expected3, balance3)
      })
    })

    describe('withdraw', () => {
      let request: h.RunRequest

      beforeEach(async () => {
        agreement = await h.newServiceAgreement({
          aggregator: meanAggregator.address,
          oracles: [roles.oracleNode1, roles.oracleNode2, roles.oracleNode3],
        })
        sAID = h.generateSAID(agreement)

        const tx1 = await h.initiateServiceAgreement(coordinator, agreement)
        const receipt1 = await tx1.wait()
        const event1 = h.findEventIn(receipt1, newServiceAgreementEvent)
        const { said: loggedSAID } = newServiceAgreementEvent.decode(
          event1.data,
          event1.topics,
        )
        assert.equal(loggedSAID, sAID)

        mock = await getterSetterFactory.connect(roles.defaultAccount).deploy()

        const fHash =
          getterSetterFactory.interface.functions.requestedUint256.sighash

        const payload = h.executeServiceAgreementBytes(
          sAID,
          mock.address,
          fHash,
          1,
        )
        const tx2 = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
        )
        const receipt2 = await tx2.wait()
        const event2 = h.findEventIn(receipt2, oracleRequestEvent)
        request = h.decodeRunRequest(event2)

        await coordinator
          .connect(roles.oracleNode1)
          .fulfillOracleRequest(request.id, h.numToBytes32(16))
        await coordinator
          .connect(roles.oracleNode2)
          .fulfillOracleRequest(request.id, h.numToBytes32(17))
        await coordinator
          .connect(roles.oracleNode3)
          .fulfillOracleRequest(request.id, h.numToBytes32(18))

        const currentValue = await mock.getUint256()
        assertBigNum(h.bigNum(17), currentValue)
      })

      it('allows the oracle to withdraw their full amount', async () => {
        const coordBalance1 = await link.balanceOf(coordinator.address)
        const withdrawAmount = await coordinator.withdrawableTokens(oracle1)
        await coordinator
          .connect(roles.oracleNode1)
          .withdraw(oracle1, withdrawAmount)
        const oracleBalance = await link.balanceOf(oracle1)
        const afterWithdrawBalance = await coordinator
          .connect(roles.oracleNode1)
          .withdrawableTokens(oracle1)
        const coordBalance2 = await link.balanceOf(coordinator.address)
        const expectedCoordFinalBalance = coordBalance1.sub(withdrawAmount)
        assertBigNum(withdrawAmount, oracleBalance)
        assertBigNum(expectedCoordFinalBalance, coordBalance2)
        assertBigNum(h.bigNum(0), afterWithdrawBalance)
      })

      it('rejects amounts greater than allowed', async () => {
        const oracleBalance = await coordinator.withdrawableTokens(oracle1)
        const withdrawAmount = oracleBalance.add(h.bigNum(1))
        await h.assertActionThrows(
          coordinator
            .connect(roles.oracleNode1)
            .withdraw(oracle1, withdrawAmount),
        )
      })
    })
  })

  describe('#depositFunds', () => {
    async function assertBalances({
      link: linkBal,
      coordinator: coordBal,
    }: {
      link: BigNumberish
      coordinator: BigNumberish
    }) {
      const linkBalance = await link.balanceOf(oracle1)
      const coordinatorBalance = await coordinator.balanceOf(oracle1)
      assertBigNum(linkBalance, linkBal)
      assertBigNum(coordinatorBalance, coordBal)
    }

    beforeEach(async () => {
      await link.transfer(oracle1, 4)
      const initialBalance = await link.balanceOf(oracle1)
      assertBigNum(initialBalance, 4)
    })

    it('permits deposit through link#transferAndCall', async () => {
      const payload = coordinatorFactory.interface.functions.depositFunds.encode(
        [oracle1, 1],
      )
      await link
        .connect(roles.oracleNode1)
        .transferAndCall(coordinator.address, 1, payload)
      await assertBalances({ link: 3, coordinator: 1 })
    })

    it('overrides invalid payloads', async () => {
      const payload = coordinatorFactory.interface.functions.depositFunds.encode(
        [coordinator.address, 2],
      )
      await link
        .connect(roles.oracleNode1)
        .transferAndCall(coordinator.address, 1, payload)
      await assertBalances({ link: 3, coordinator: 1 })
    })

    it('reverts with insufficient payloads', async () => {
      const payload =
        coordinatorFactory.interface.functions.depositFunds.sighash
      await h.assertActionThrows(
        link
          .connect(roles.oracleNode1)
          .transferAndCall(coordinator.address, 1, payload),
      )
    })

    it('allows partial withdrawals', async () => {
      const payload = coordinatorFactory.interface.functions.depositFunds.encode(
        [oracle1, 4],
      )
      await link
        .connect(roles.oracleNode1)
        .transferAndCall(coordinator.address, 4, payload)
      await coordinator.connect(roles.oracleNode1).withdraw(oracle1, 1)
      await assertBalances({ link: 1, coordinator: 3 })
    })

    it('allows full withdrawals', async () => {
      const payload = coordinatorFactory.interface.functions.depositFunds.encode(
        [oracle1, 4],
      )
      await link
        .connect(roles.oracleNode1)
        .transferAndCall(coordinator.address, 4, payload)
      await coordinator.connect(roles.oracleNode1).withdraw(oracle1, 2)
      await coordinator.connect(roles.oracleNode1).withdraw(oracle1, 2)
      await assertBalances({ link: 4, coordinator: 0 })
    })

    it('reverts when overdrawing', async () => {
      const payload = coordinatorFactory.interface.functions.depositFunds.encode(
        [oracle1, 4],
      )
      await link
        .connect(roles.oracleNode1)
        .transferAndCall(coordinator.address, 4, payload)
      await coordinator.connect(roles.oracleNode1).withdraw(oracle1, 4)
      await h.assertActionThrows(
        coordinator.connect(roles.oracleNode1).withdraw(oracle1, 1),
      )
      await assertBalances({ link: 4, coordinator: 0 })
    })
  })
})
