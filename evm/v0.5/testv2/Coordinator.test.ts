import * as h from '../src/helpers'
import { ethers } from 'ethers'
import { LinkTokenFactory } from '../src/generated/LinkTokenFactory'
import { CoordinatorFactory } from '../src/generated/CoordinatorFactory'
import { EmptyAggregatorFactory } from '../src/generated/EmptyAggregatorFactory'
import { MeanAggregatorFactory } from '../src/generated/MeanAggregatorFactory'
import { GetterSetterFactory } from '../src/generated/GetterSetterFactory'
import { MaliciousRequesterFactory } from '../src/generated/MaliciousRequesterFactory'
import { MaliciousConsumerFactory } from '../src/generated/MaliciousConsumerFactory'
import { Instance } from '../src/contract'
import { makeTestProvider } from '../src/provider'
import { assert } from 'chai'
import { assertBigNum } from '../src/matchers'
import { BigNumberish } from 'ethers/utils'

const provider = makeTestProvider()

const linkTokenFactory = new LinkTokenFactory()
const coordinatorFactory = new CoordinatorFactory()
const emptyAggregatorFactory = new EmptyAggregatorFactory()
const meanAggregatorFactory = new MeanAggregatorFactory()
const getterSetterFactory = new GetterSetterFactory()
const maliciousRequesterFactory = new MaliciousRequesterFactory()
const maliciousConsumerFactory = new MaliciousConsumerFactory()

let roles: h.Roles

const fs = (name: string) =>
  h.getFunctionSignature(emptyAggregatorFactory, name)
const partialServiceAgreement = {
  aggInitiateJobSelector: fs('initiateJob'), // Currently, meanAggregator and emptyAggregator have the same signatures
  aggFulfillSelector: fs('fulfill'),
}

async function initiateServiceAgreement(
  coordinator: Instance<CoordinatorFactory>,
  serviceAgreement: h.ServiceAgreement,
) {
  const signers = serviceAgreement.oracles.map(address =>
    h.getWallet(address, roles),
  )
  const signatures = await h.generateOracleSignatures(serviceAgreement, signers)
  return coordinator.initiateServiceAgreement(
    h.encodeServiceAgreement(serviceAgreement),
    h.encodeOracleSignatures(signatures),
  )
}

const newServiceAgreement = async (
  sA?: Partial<h.ServiceAgreement>,
): Promise<h.ServiceAgreement> => {
  return h.newServiceAgreement({
    oracles: [roles.oracleNode.address],
    ...partialServiceAgreement,
    ...sA,
  })
}

let link: Instance<LinkTokenFactory>
let coordinator: Instance<CoordinatorFactory>
let emptyAggregator: Instance<EmptyAggregatorFactory>
let meanAggregator: Instance<MeanAggregatorFactory>
let getterSetter: Instance<GetterSetterFactory>
let oracle1: string, oracle2: string, oracle3: string
let oracles: string[]

const deployment = h.useSnapshot(provider, async () => {
  link = await linkTokenFactory.connect(roles.defaultAccount).deploy()
  coordinator = await coordinatorFactory
    .connect(roles.defaultAccount)
    .deploy(link.address)
  emptyAggregator = await emptyAggregatorFactory
    .connect(roles.defaultAccount)
    .deploy()
  meanAggregator = await meanAggregatorFactory
    .connect(roles.defaultAccount)
    .deploy()
  getterSetter = await getterSetterFactory
    .connect(roles.defaultAccount)
    .deploy()
})

beforeAll(async () => {
  roles = await h.initializeRolesAndPersonas(provider).then(x => x.roles)
  oracle1 = roles.oracleNode1.address
  oracle2 = roles.oracleNode2.address
  oracle3 = roles.oracleNode3.address
  oracles = [oracle1, oracle2, oracle3]
})

beforeEach(async () => {
  await deployment()
  link = link.connect(roles.defaultAccount)
  coordinator = coordinator.connect(roles.defaultAccount)
  emptyAggregator = emptyAggregator.connect(roles.defaultAccount)
  meanAggregator = meanAggregator.connect(roles.defaultAccount)
  getterSetter = getterSetter.connect(roles.defaultAccount)
})

describe('Coordinator', () => {
  it('has a limited public interface', () => {
    h.checkPublicABI(coordinatorFactory, [
      'EXPIRY_TIME',
      'balanceOf',
      'cancelOracleRequest',
      'depositFunds',
      'fulfillOracleRequest',
      'getId',
      'initiateServiceAgreement',
      'onTokenTransfer',
      'oracleRequest',
      'serviceAgreements',
      'withdraw',
      'withdrawableTokens',
    ])
  })

  describe('#getId', () => {
    it('matches the ID generated by the oracle off-chain', async () => {
      const agreement = await newServiceAgreement({
        payment: 1,
        expiration: 2,
        requestDigest:
          '0x85820c5ec619a1f517ee6cfeff545ec0ca1a90206e1a38c47f016d4137e801dd',
        aggregator: emptyAggregator.address,
      })
      const sAID = h.generateSAID(agreement)
      const sAAsData = h.encodeServiceAgreement(agreement)
      const result = await coordinator.getId(sAAsData)
      assert.equal(result.toLowerCase(), sAID)
    })
  })

  describe('#initiateServiceAgreement', () => {
    describe('with valid oracle signatures', () => {
      let serviceAgreement: h.ServiceAgreement,
        sAID: string,
        receipt: ethers.providers.TransactionReceipt

      beforeEach(async () => {
        serviceAgreement = await newServiceAgreement({
          oracles: [roles.oracleNode.address],
          aggregator: emptyAggregator.address,
        })
        sAID = h.generateSAID(serviceAgreement)
        const tx = await initiateServiceAgreement(coordinator, serviceAgreement)
        receipt = await tx.wait()
      })

      it('saves a service agreement struct from the parameters', async () => {
        await h.checkServiceAgreementPresent(coordinator, serviceAgreement)
      })

      it('generates the SAID', async () => {
        const ethSAID = await coordinator.getId(
          h.encodeServiceAgreement(serviceAgreement),
        )
        assert.equal(ethSAID, sAID)
      })

      it('logs an event', async () => {
        expect(
          h.findEventIn(
            receipt,
            coordinator.interface.events.NewServiceAgreement,
          ),
        ).toBeDefined()
      })

      it('calls the aggregator with the SA info', async () => {
        const event = h.findEventIn(
          receipt,
          coordinator.interface.events.NewServiceAgreement,
        )
        assert(event, 'event was expected')
        const { said } = h.eventArgs(
          h.findEventIn(
            receipt,
            coordinator.interface.events.NewServiceAgreement,
          ),
        )
        assert.equal(said, sAID)
      })
    })

    describe('with an invalid oracle signature', () => {
      it('saves no service agreement struct, if signatures invalid', async () => {
        const serviceAgreement = await newServiceAgreement({
          oracles: [roles.oracleNode.address],
          aggregator: emptyAggregator.address,
        })
        const sAID = h.generateSAID(serviceAgreement)
        const badOracleSignature = await h.personalSign(sAID, roles.stranger)
        const badRequestDigestAddr = h.recoverPersonalSignature(
          sAID,
          badOracleSignature,
        )
        assert.equal(roles.stranger.address, badRequestDigestAddr)
        const conbinedSignatures = h.combineOracleSignatures([
          badOracleSignature,
        ])
        await h.assertActionThrows(
          coordinator.initiateServiceAgreement(
            h.encodeServiceAgreement(serviceAgreement),
            h.encodeOracleSignatures(conbinedSignatures),
          ),
        )
        await h.checkServiceAgreementAbsent(coordinator, sAID)
      })
    })

    describe('Validation of service agreement deadlines', () => {
      it('Rejects a service agreement with an endAt date in the past', async () => {
        const serviceAgreement = await newServiceAgreement({
          endAt: 1,
          aggregator: emptyAggregator.address,
        })
        const sAID = h.generateSAID(serviceAgreement)
        await h.assertActionThrows(
          initiateServiceAgreement(coordinator, serviceAgreement),
        )
        await h.checkServiceAgreementAbsent(coordinator, sAID)
      })
    })
  })

  describe('#oracleRequest', () => {
    const to = '0x80e29acb842498fe6591f020bd82766dce619d43'
    let agreement: h.ServiceAgreement, fHash: string, sAID: string

    beforeEach(async () => {
      fHash = h.getFunctionSignature(getterSetter, 'requestedBytes32')
      agreement = await newServiceAgreement({
        aggregator: meanAggregator.address,
      })
      sAID = h.generateSAID(agreement)
      await initiateServiceAgreement(coordinator, agreement)
      await link.transfer(roles.consumer.address, h.toWei('1000'))
    })

    describe('when called through the LINK token with enough payment', () => {
      it('logs an event', async () => {
        const payload = h.executeServiceAgreementBytes(sAID, to, fHash, '1')

        link = link.connect(roles.consumer)
        const tx = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
        )
        const log = await h.getLog(tx, 2)
        const addressLog = log.address
        assert.equal(coordinator.address, addressLog)
        // If updating this test, be sure to update
        // services.RunLogTopic20190207withoutIndexes. (Which see for the
        // calculation of this hash.)
        const eventSignature =
          '0xd8d7ecc4800d25fa53ce0372f13a416d98907a7ef3d8d3bdd79cf4fe75529c65'
        const eventSigLog = log.topics[0]
        assert.equal(eventSignature, eventSigLog)
        const sAIDLog = log.topics[1]
        assert.equal(sAID, sAIDLog)
        const req = h.decodeRunRequest(log)
        assertBigNum(
          roles.consumer.address,
          req.requester,
          "Logged consumer address doesn't match",
        )
        assertBigNum(
          agreement.payment,
          req.payment,
          "Logged payment amount doesn't match",
        )
      })
    })

    describe('when called through the LINK token with not enough payment', () => {
      it('throws an error', async () => {
        const calldata = h.executeServiceAgreementBytes(sAID, to, fHash, '1')
        const underPaid = h
          .bigNum(agreement.payment)
          .sub(h.bigNum(1))
          .toString()
        link = link.connect(roles.consumer)
        await h.assertActionThrows(
          link.transferAndCall(coordinator.address, underPaid, calldata),
        )
      })
    })

    describe('when not called through the LINK token', () => {
      it('reverts', async () => {
        coordinator = coordinator.connect(roles.consumer)
        await h.assertActionThrows(
          coordinator.oracleRequest(
            ethers.constants.AddressZero,
            0,
            sAID,
            to,
            fHash,
            1,
            1,
            '0x',
          ),
          'Must use LINK token',
        )
      })
    })
  })

  describe('#fulfillOracleRequest', () => {
    let agreement: h.ServiceAgreement,
      sAID: string,
      mock: Instance<GetterSetterFactory>,
      request: h.RunRequest
    beforeEach(async () => {
      agreement = await newServiceAgreement({
        oracles: [roles.oracleNode.address],
        aggregator: meanAggregator.address,
      })
      sAID = h.generateSAID(agreement)
      const tx = await initiateServiceAgreement(coordinator, agreement)
      const log = await h.getLog(tx, 0)
      const sAIDLog = log.topics[1]
      assert.equal(sAIDLog, sAID)
    })

    const fHash = h.getFunctionSignature(
      getterSetterFactory,
      'requestedBytes32',
    )

    describe('cooperative consumer', () => {
      const message = h.toBytes32String('Hello World!')
      beforeEach(async () => {
        mock = await getterSetterFactory.connect(roles.defaultAccount).deploy()
        const payload = h.executeServiceAgreementBytes(
          sAID,
          mock.address,
          fHash,
          1,
        )
        const tx = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
          { value: 0 },
        )
        const log = await h.getLog(tx, 2)
        request = h.decodeRunRequest(log)
      })

      describe('when called by a non-owner', () => {
        // Turn this test on when multiple-oracle response aggregation is enabled
        xit('raises an error', async () => {
          coordinator = coordinator.connect(roles.stranger)
          await h.assertActionThrows(
            coordinator.fulfillOracleRequest(request.id, message),
          )
        })
      })

      describe('when called by an owner', () => {
        beforeEach(() => {
          coordinator = coordinator.connect(roles.oracleNode)
        })

        it('raises an error if the request ID does not exist', async () => {
          const invalidRequestId = h.toBytes32String('deadbeef')
          await h.assertActionThrows(
            coordinator.fulfillOracleRequest(invalidRequestId, message),
          )
        })

        it('sets the value on the requested contract', async () => {
          await coordinator.fulfillOracleRequest(request.id, message)
          const mockRequestId = await mock.requestId()
          assert.equal(h.toHex(request.id), mockRequestId)
          const currentValue = await mock.getBytes32()
          assert.equal('Hello World!', h.parseBytes32String(currentValue))
        })

        it('reports errors from the aggregator, such as double-reporting', async () => {
          const firstMessage = h.toBytes32String('First message!')
          const seccondMessage = h.toBytes32String('Second message!!')
          await coordinator.fulfillOracleRequest(request.id, firstMessage)
          await h.assertActionThrows(
            coordinator.fulfillOracleRequest(request.id, seccondMessage),
            'oracle already reported',
          )
        })
      })
    })

    describe('with a malicious requester', () => {
      let mock: Instance<MaliciousRequesterFactory>
      const paymentAmount = h.toWei('1')

      beforeEach(async () => {
        mock = await maliciousRequesterFactory
          .connect(roles.defaultAccount)
          .deploy(link.address, coordinator.address)
        await link.transfer(mock.address, paymentAmount)
      })

      xit('cannot cancel before the expiration', async () => {
        await h.assertActionThrows(
          mock.maliciousRequestCancel(sAID, 'doesNothing(bytes32,bytes32)'),
        )
      })

      it('cannot call functions on the LINK token through callbacks', async () => {
        await h.assertActionThrows(
          mock.request(
            sAID,
            link.address,
            h.encodeFunctionSignature('transfer(address,uint256)'),
          ),
        )
      })

      describe('requester lies about amount of LINK sent', () => {
        it('the oracle uses the amount of LINK actually paid', async () => {
          const tx = await mock.maliciousPrice(sAID)
          const log = await h.getLog(tx, 3)
          const req = h.decodeRunRequest(log)
          assertBigNum(
            paymentAmount,
            req.payment,
            [
              'Malicious data request tricked oracle into refunding more than',
              'the requester paid, by claiming a larger amount',
              `(${req.payment}) than the requester paid (${paymentAmount})`,
            ].join(' '),
          )
        })
      })
    })

    describe('with a malicious consumer', () => {
      const paymentAmount = h.toWei('1')
      let mock: Instance<MaliciousConsumerFactory>

      beforeEach(async () => {
        mock = await maliciousConsumerFactory
          .connect(roles.defaultAccount)
          .deploy(link.address, coordinator.address)
        await link.transfer(mock.address, paymentAmount)
        coordinator = coordinator.connect(roles.oracleNode)
      })

      describe('fails during fulfillment', () => {
        beforeEach(async () => {
          const tx = await mock.requestData(
            sAID,
            h.encodeFunctionSignature('assertFail(bytes32,bytes32)'),
          )
          const log = await h.getLog(tx, 3)
          request = h.decodeRunRequest(log)
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator.fulfillOracleRequest(
            request.id,
            h.toBytes32String('hack the planet 101'),
          )

          const balance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(balance, 0)

          await coordinator.withdraw(roles.oracleNode.address, paymentAmount)
          const newBalance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(paymentAmount, newBalance)
        })

        it("can't fulfill the data again", async () => {
          await coordinator.fulfillOracleRequest(
            request.id,
            h.toBytes32String('hack the planet 101'),
          )
          await h.assertActionThrows(
            coordinator.fulfillOracleRequest(
              request.id,
              h.toBytes32String('hack the planet 102'),
            ),
            'oracle already reported',
          )
        })
      })

      describe('calls selfdestruct', () => {
        beforeEach(async () => {
          const tx = await mock.requestData(
            sAID,
            h.encodeFunctionSignature('doesNothing(bytes32,bytes32)'),
          )
          const log = await h.getLog(tx, 3)
          request = h.decodeRunRequest(log)
          await mock.remove()
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator.fulfillOracleRequest(
            request.id,
            h.toBytes32String('hack the planet 101'),
          )

          const balance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(balance, 0)

          await coordinator.withdraw(roles.oracleNode.address, paymentAmount)
          const newBalance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(paymentAmount, newBalance)
        })
      })

      describe('request is canceled during fulfillment', () => {
        beforeEach(async () => {
          const tx = await mock.requestData(
            sAID,
            h.encodeFunctionSignature(
              'cancelRequestOnFulfill(bytes32,bytes32)',
            ),
          )
          const log = await h.getLog(tx, 3)
          request = h.decodeRunRequest(log)
          const mockBalance = await link.balanceOf(mock.address)
          assertBigNum(mockBalance, h.bigNum(0))
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator.fulfillOracleRequest(
            request.id,
            h.toBytes32String('hack the planet 101'),
          )
          const mockBalance = await link.balanceOf(mock.address)
          assertBigNum(mockBalance, 0)
          const balance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(balance, 0)
          await coordinator.withdraw(roles.oracleNode.address, paymentAmount)
          const newBalance = await link.balanceOf(roles.oracleNode.address)
          assertBigNum(paymentAmount, newBalance)
        })

        it("can't fulfill the data again", async () => {
          await coordinator.fulfillOracleRequest(
            request.id,
            h.toBytes32String('hack the planet 101'),
          )
          await h.assertActionThrows(
            coordinator.fulfillOracleRequest(
              request.id,
              h.toBytes32String('hack the planet 102'),
            ),
          )
        })
      })
    })

    describe('when aggregating answers', () => {
      let request: h.RunRequest

      beforeEach(async () => {
        agreement = await newServiceAgreement({
          aggregator: meanAggregator.address,
          oracles,
        })
        sAID = h.generateSAID(agreement)

        const tx1 = await initiateServiceAgreement(coordinator, agreement)
        const log1 = await h.getLog(tx1, 0)
        const sAIDLog = log1?.topics[1]
        assert.equal(sAIDLog, sAID)

        mock = await getterSetterFactory.connect(roles.defaultAccount).deploy()

        const fHash = h.getFunctionSignature(
          getterSetterFactory,
          'requestedUint256',
        )

        const payload = h.executeServiceAgreementBytes(
          sAID,
          mock.address,
          fHash,
          1,
        )
        const tx2 = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
          { value: 0 },
        )
        const log2 = await h.getLog(tx2, 2)
        request = h.decodeRunRequest(log2)
      })

      it('does not set the value with only one oracle', async () => {
        coordinator = coordinator.connect(roles.oracleNode1)
        const tx = await coordinator.fulfillOracleRequest(
          request.id,
          h.numToBytes32(17),
        )
        const logs = await h.getLogs(tx)
        assert.equal(logs.length, 0) // No logs emitted = consuming contract not called
      })

      it('sets the average of the reported values', async () => {
        coordinator = coordinator.connect(roles.oracleNode1)
        await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(16))
        coordinator = coordinator.connect(roles.oracleNode2)
        await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(17))
        coordinator = coordinator.connect(roles.oracleNode3)
        const tx = await coordinator.fulfillOracleRequest(
          request.id,
          h.numToBytes32(18),
        )
        const logs = await h.getLogs(tx)
        assert.equal(logs.length, 1)
        const currentValue = await mock.getUint256()
        assertBigNum(currentValue, 17)
      })

      describe('when large values are provided in response', () => {
        // (uint256(-1) / 2) - 1
        const largeValue1 =
          '0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe'
        // (uint256(-1) / 2)
        const largeValue2 =
          '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'
        // (uint256(-1) / 2) + 1
        const largeValue3 =
          '0x8000000000000000000000000000000000000000000000000000000000000000'

        beforeEach(async () => {
          coordinator = coordinator.connect(roles.oracleNode1)
          await coordinator.fulfillOracleRequest(request.id, largeValue1)
          coordinator = coordinator.connect(roles.oracleNode2)
          await coordinator.fulfillOracleRequest(request.id, largeValue2)
          coordinator = coordinator.connect(roles.oracleNode3)
        })

        it('does not overflow', async () => {
          await coordinator.fulfillOracleRequest(request.id, largeValue3)
        })

        it('sets the average of the reported values', async () => {
          await coordinator.fulfillOracleRequest(request.id, largeValue3)
          const currentValue = await mock.getUint256()
          assertBigNum(largeValue2, currentValue)
          assert.notEqual(h.bigNum(0), h.bigNum(await mock.requestId())) // check if called
        })
      })

      it('successfully sets average when responses equal largest uint256', async () => {
        const largest =
          '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'

        coordinator = coordinator.connect(roles.oracleNode1)
        await coordinator.fulfillOracleRequest(request.id, largest)
        coordinator = coordinator.connect(roles.oracleNode2)
        await coordinator.fulfillOracleRequest(request.id, largest)
        coordinator = coordinator.connect(roles.oracleNode3)
        await coordinator.fulfillOracleRequest(request.id, largest)
        const currentValue = await mock.getUint256()
        assertBigNum(h.bigNum(largest), currentValue)
        assert.notEqual(h.bigNum(0), h.bigNum(await mock.requestId())) // check if called
      })

      it('rejects oracles not part of the service agreement', async () => {
        coordinator = coordinator.connect(roles.stranger)

        await h.assertActionThrows(
          coordinator.fulfillOracleRequest(request.id, h.numToBytes32(18)),
        )
      })

      describe('when an oracle reports multiple times', () => {
        beforeEach(async () => {
          coordinator = coordinator.connect(roles.oracleNode1)
          await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(16))
          coordinator = coordinator.connect(roles.oracleNode2)
          await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(17))
          await h.assertActionThrows(
            coordinator.fulfillOracleRequest(request.id, h.numToBytes32(18)),
          )
        })

        it('does not set the average', async () => {
          assertBigNum(0, await mock.requestId()) // check if called
        })

        it('still allows the other oracles to report', async () => {
          coordinator = coordinator.connect(roles.oracleNode3)
          await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(18))
          const currentValue = await mock.getUint256()
          assertBigNum(h.bigNum(17), currentValue)
          assert.notEqual(h.bigNum(0), h.bigNum(await mock.requestId())) // check if called
        })
      })
    })

    describe('after aggregation', () => {
      let request: h.RunRequest

      beforeEach(async () => {
        agreement = await newServiceAgreement({
          aggregator: meanAggregator.address,
          oracles,
        })
        sAID = h.generateSAID(agreement)

        const tx1 = await initiateServiceAgreement(coordinator, agreement)
        const log1 = await h.getLog(tx1, 0)
        const sAIDLog = log1.topics[1]
        assert.equal(sAIDLog, sAID)

        mock = await getterSetterFactory.connect(roles.defaultAccount).deploy()

        const fHash = h.getFunctionSignature(
          getterSetterFactory,
          'requestedUint256',
        )

        const payload = h.executeServiceAgreementBytes(
          sAID,
          mock.address,
          fHash,
          1,
        )
        const tx = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
          { value: 0 },
        )

        const log = await h.getLog(tx, 2)
        request = h.decodeRunRequest(log)

        coordinator = coordinator.connect(roles.oracleNode1)
        await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(16))
        coordinator = coordinator.connect(roles.oracleNode2)
        await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(17))
        coordinator = coordinator.connect(roles.oracleNode3)
        await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(18))

        const currentValue = await mock.getUint256()
        assertBigNum(h.bigNum(17), currentValue)
      })

      it('oracle balances are updated', async () => {
        // Given the 3 oracles from the SA, each should have the following balance after fulfillment
        const expected1 = h.bigNum('555555555555555555')
        const expected2 = h.bigNum('333333333333333333')
        const expected3 = h.bigNum('111111111111111111')
        const balance1 = await coordinator.withdrawableTokens(oracle1)
        const balance2 = await coordinator.withdrawableTokens(oracle2)
        const balance3 = await coordinator.withdrawableTokens(oracle3)
        assertBigNum(expected1, balance1)
        assertBigNum(expected2, balance2)
        assertBigNum(expected3, balance3)
      })
    })

    describe('withdraw', () => {
      let request: h.RunRequest

      beforeEach(async () => {
        agreement = await newServiceAgreement({
          aggregator: meanAggregator.address,
          oracles,
        })
        sAID = h.generateSAID(agreement)

        const tx1 = await initiateServiceAgreement(coordinator, agreement)
        const log1 = await h.getLog(tx1, 0)
        const sAIDLog = log1.topics[1]
        assert.equal(sAIDLog, sAID)

        mock = await getterSetterFactory.connect(roles.defaultAccount).deploy()

        const fHash = h.getFunctionSignature(
          getterSetterFactory,
          'requestedUint256',
        )

        const payload = h.executeServiceAgreementBytes(
          sAID,
          mock.address,
          fHash,
          1,
        )
        const tx2 = await link.transferAndCall(
          coordinator.address,
          agreement.payment,
          payload,
          { value: 0 },
        )

        const log2 = await h.getLog(tx2, 2)
        request = h.decodeRunRequest(log2)

        coordinator = coordinator.connect(roles.oracleNode1)
        await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(16))
        coordinator = coordinator.connect(roles.oracleNode2)
        await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(17))
        coordinator = coordinator.connect(roles.oracleNode3)
        await coordinator.fulfillOracleRequest(request.id, h.numToBytes32(18))

        const currentValue = await mock.getUint256()
        assertBigNum(h.bigNum(17), currentValue)
      })

      it('allows the oracle to withdraw their full amount', async () => {
        const coordBalance1 = await link.balanceOf(coordinator.address)
        const withdrawAmount = await coordinator.withdrawableTokens(oracle1)
        coordinator = coordinator.connect(roles.oracleNode1)
        await coordinator.withdraw(oracle1, withdrawAmount)
        const oracleBalance = await link.balanceOf(oracle1)
        const afterWithdrawBalance = await coordinator.withdrawableTokens(
          oracle1,
        )
        const coordBalance2 = await link.balanceOf(coordinator.address)
        const expectedCoordFinalBalance = coordBalance1.sub(withdrawAmount)
        assertBigNum(withdrawAmount, oracleBalance)
        assertBigNum(expectedCoordFinalBalance, coordBalance2)
        assertBigNum(h.bigNum(0), afterWithdrawBalance)
      })

      it('rejects amounts greater than allowed', async () => {
        const oracleBalance = await coordinator.withdrawableTokens(oracle1)
        const withdrawAmount = oracleBalance.add(h.bigNum(1))
        coordinator.connect(roles.oracleNode1)
        await h.assertActionThrows(
          coordinator.withdraw(oracle1, withdrawAmount),
        )
      })
    })
  })

  describe('#depositFunds', () => {
    const assertBalances = async ({
      link: linkBal,
      coordinator: coordBal,
    }: {
      link: BigNumberish
      coordinator: BigNumberish
    }) => {
      const linkBalance = await link.balanceOf(oracle1)
      const coordinatorBalance = await coordinator.balanceOf(oracle1)
      assertBigNum(linkBalance, linkBal)
      assertBigNum(coordinatorBalance, coordBal)
    }

    beforeEach(async () => {
      await link.transfer(oracle1, 4)
      const initialBalance = await link.balanceOf(oracle1)
      assertBigNum(initialBalance, 4)
      link = link.connect(roles.oracleNode1)
      coordinator = coordinator.connect(roles.oracleNode1)
    })

    it('permits deposit through link#transferAndCall', async () => {
      const payload = h.depositFundsBytes(oracle1, 1)
      await link.transferAndCall(coordinator.address, 1, payload)
      await assertBalances({ link: 3, coordinator: 1 })
    })

    it('overrides invalid payloads', async () => {
      const payload = h.depositFundsBytes(coordinator.address, 2) // wrong value and address
      await link.transferAndCall(coordinator.address, 1, payload)
      await assertBalances({ link: 3, coordinator: 1 })
    })

    it('reverts with insufficient payloads', async () => {
      const payload = h.encodeFunctionSignature('depositFunds(address,uint256)')
      await h.assertActionThrows(
        link.transferAndCall(coordinator.address, 1, payload),
      )
    })

    it('allows partial withdrawals', async () => {
      const payload = h.depositFundsBytes(oracle1, 4)
      await link.transferAndCall(coordinator.address, 4, payload)
      await coordinator.withdraw(oracle1, 1)
      await assertBalances({ link: 1, coordinator: 3 })
    })

    it('allows full withdrawals', async () => {
      const payload = h.depositFundsBytes(oracle1, 4)
      await link.transferAndCall(coordinator.address, 4, payload)
      await coordinator.withdraw(oracle1, 2)
      await coordinator.withdraw(oracle1, 2)
      await assertBalances({ link: 4, coordinator: 0 })
    })

    it('reverts when overdrawing', async () => {
      const payload = h.depositFundsBytes(oracle1, 4)
      await link.transferAndCall(coordinator.address, 4, payload)
      await coordinator.withdraw(oracle1, 4)
      await h.assertActionThrows(coordinator.withdraw(oracle1, 1))
      await assertBalances({ link: 4, coordinator: 0 })
    })
  })
})
